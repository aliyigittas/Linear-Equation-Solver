# Project 3 Report
## Level 1
In level 1, equations are directly integrated in source code. But its easily changeable. For example, you can see matrix array elements as {{2,1,-1,1},{3,4,2,13},{1,-5,-2,0}} This equal to this: 2x+y-z=1 and 3x+4y+2z=13 and x-5y-2z=0. And also, you need to define unknown numbers in 14th line for example its 3 now, but when put an equation with 4 variables, you need to change here as 4. In next, the nmatrix is a backup array, this is used for restarting program with same variables when user wanted to. Result array represents results, unknames array stores unknown names. Again variable is used in switch when program ends. Unknum is equal to defined unknownumber. Linenum is equal to unknum this is for better understanding. Coeffnum is number of unknowns +1(right side of equation). Nanvalue and infvalue variables is used for checking multiple and no solutions as a bonus feature. Ratio valuable is solving phase ratios are stored in here. Placenumber is used in back-substitution part when the perpendicular triangle is completed in matrix. PrintEquations function shows equations that the program has solved. PrintMatrix function creates matrix form. Solve function is the hearth of the code. Solving part repeats until perpendicular triangle in matrix is completed. We check that situation with if condition in 85th line. i>j (j is vertical, i is horizontal) is true in these conditions: for example, second line first element, third line first and second element etc. Then we get the ratio of second and first line in this case, its 3/2. Then we will multiply all first line elements with this ratio and substract these from second line. Then second line first element is turned zero (3-((3/2)*2). This operation performs until matrix looks like this:

<img width="185" alt="Resim1" src="https://user-images.githubusercontent.com/48025526/170843927-18433972-19c2-47a5-a54b-bc2a33ee450b.png">


You can see the perpendicular triangle with zeros in here.

After that, this program retrieves results by doing back-substitution. In first program gets ratio of last element in last line and their solution (in this case 6.20/24.80) and program shifts to upper line (we used iâ€”in for loop to do this). Placenumber stores multiplification of founded unknown and coefficient in upper line (in this case, 4*3.50, equals 14). Then substract this number from right side of equation (in this case, 11.50-(14), equals -2.50). Then gets ratio of unknown number and right side of that equation (-2.50/2.50, equals -1). This operation performs until program reaches to the first line. And program prints results with PrintResults function. In here, as a bonus, program checks multiple and no solutions checking by NaN and inf values. NaN value means that 0/0, this means all elements in last line is zero, this is multiple solution. Inf value means that a value divided by 0 for example 7/0 this means that this equation has no solution. After that, in AfterSolving function, program asks from user to repeat all operations from beginning. If user selects yes, that backup array (nmatrix) is transferred to matrix array and all operations starts again. If user selects no, program terminates, if user pressed undefined key, bonus feature is here, this function repeats (recursive function bonus). This was Level 1.

## Level 2
First, we start the code by opening the File. This allows us to get the equation in the file that is ready beforehand. Then we check the characters in the code with a for loop and separate them from the numbers. We do this for the right and left sides of the equation. Afterwards, we check whether all the variables exist in the array we set up and add them with the_first_line_has_been_done. In the continuation of the code, we write the lines we have into another file and turn the "=" signs into " ". This process makes it easier for us to do the %f%c command. We find the coefficients of the variables with %f%c from the file. We examine the existence of all variables in the string we set up with the true-false command, which we call Decider. Then we look at the length of the strings. By doing what we did before, we separate the numbers and letters in the equation with the isalpha command. We open the numbers which coefficients we found in a file and add "1" by looking plus or minus in front of the ones that do not have coefficients. Then we open one of our same old files and turn the "=" signs into "+" signs. By placing a * sign after the constant characters at the end of the equations, we indicate that they are the last constant in the equation. We are checking variable and coefficient again. We check whether all the variables in the equation and all the variables in our array match. Afterwards, we place the variables in the matrix with control one by one from each equation. If all_the_variables and variables_control match, we write it as "1" in the matrix, otherwise we write it as "0". We go to the math operation part and reset until only one variable remains from the values in the matrix. How many variables there are in the matrix, these variables eliminate each other each time. And at the end, every variable equals a constant. When an equation with multiple solutions is entered, the code gives a warning that this equation has more than one solution, and if there is no solution to the equation, it gives a warning that this equation has no solution. In the last part of the code, it wants to press "1" in case the program is requested to be closed.
